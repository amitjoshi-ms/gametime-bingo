name: Release to Production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "release" to confirm'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: read

jobs:
  # Pre-release validation job
  validate:
    name: Pre-Release Validation
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm == 'release'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run type check
        run: npm run check

      - name: Run unit tests
        run: npm run test

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: build-artifacts
          path: dist/
          retention-days: 7

  release:
    name: Release to Production
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Determine version
        id: version
        run: |
          # Date-based versioning: YY.MDD.REV
          # YY = 2-digit year, M = month (1-12), DD = day (01-31), REV = revision (0-based)
          YEAR=$(date -u +"%y")
          MONTH=$(date -u +"%-m")  # Month without leading zero
          DAY=$(date -u +"%d")    # Day with leading zero
          MDD="${MONTH}${DAY}"
          
          # Find existing tags for today to determine revision
          TAG_PREFIX="${YEAR}.${MDD}."
          echo "Looking for existing tags with prefix: $TAG_PREFIX"
          
          # Get the highest revision for today's date
          LATEST_REV=$(git tag -l "${TAG_PREFIX}*" | sed "s/${TAG_PREFIX}//" | sort -n | tail -1)
          
          if [ -z "$LATEST_REV" ]; then
            REV=0
          else
            REV=$((LATEST_REV + 1))
          fi
          
          NEW_VERSION="${YEAR}.${MDD}.${REV}"
          TAG_NAME="${NEW_VERSION}"
          
          echo "New version: $NEW_VERSION"
          echo "Tag name: $TAG_NAME"
          
          # Output for later steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Get the latest tag (date-based format YY.DDD.REV) or fall back to HEAD~10 (then first commit if needed)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-parse HEAD~10 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Latest tag/commit: $LATEST_TAG"
          
          # Generate changelog from commits
          echo "# Changelog for ${{ steps.version.outputs.tag_name }}" > CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          echo "**Release Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          # Group commits by type (using simple patterns - ^feat matches both feat: and feat(scope):)
          echo "## üöÄ Features" >> CHANGELOG_TEMP.md
          FEATURES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^feat" 2>/dev/null || true)
          if [ -n "$FEATURES" ]; then
            echo "$FEATURES" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No new features" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "## üêõ Bug Fixes" >> CHANGELOG_TEMP.md
          FIXES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^fix" 2>/dev/null || true)
          if [ -n "$FIXES" ]; then
            echo "$FIXES" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No bug fixes" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "## üìù Other Changes" >> CHANGELOG_TEMP.md
          OTHER=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^chore\|^docs\|^refactor\|^test\|^ci" --extended-regexp 2>/dev/null || true)
          if [ -n "$OTHER" ]; then
            echo "$OTHER" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No other changes" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          
          # Store changelog for release notes
          echo "changelog_file=CHANGELOG_TEMP.md" >> $GITHUB_OUTPUT

      - name: Fast-forward release to main and update version
        run: |
          git checkout release
          if ! git merge --ff-only origin/main; then
            echo "::error::Fast-forward merge failed. The release branch may have diverged from main."
            echo "::error::To fix: git checkout release && git reset --hard origin/main (WARNING: this discards release-only commits)"
            exit 1
          fi
          
          # Now update version on the release branch
          npm version ${{ steps.version.outputs.version }} --no-git-tag-version
          git add package.json package-lock.json
          
          # Commit version bump if there were changes; otherwise verify version consistency
          if ! git diff --staged --quiet; then
            git commit -m "chore(release): bump version to ${{ steps.version.outputs.version }}"
          else
            # No changes detected; verify that package.json already matches the expected release version
            PKG_VERSION=$(node -p "require('./package.json').version")
            if [ "$PKG_VERSION" != "${{ steps.version.outputs.version }}" ]; then
              echo "::error::Version mismatch: package.json has $PKG_VERSION but expected ${{ steps.version.outputs.version }}."
              echo "::error::Refusing to create a release with inconsistent version metadata."
              exit 1
            fi
            echo "Version already matches expected: $PKG_VERSION"
          fi
          
          git push origin release

      - name: Create release tag and GitHub release
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Create and push tag
          git tag "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
          
          # Create GitHub release with changelog
          gh release create "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes-file CHANGELOG_TEMP.md \
            --target release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4.1.3
        with:
          name: build-artifacts
          path: dist/

      - name: Create release artifacts archive
        run: |
          # Create archive of build artifacts for potential rollback
          tar -czf release-${{ steps.version.outputs.tag_name }}-artifacts.tar.gz dist/
          
          # Upload to release
          gh release upload ${{ steps.version.outputs.tag_name }} \
            release-${{ steps.version.outputs.tag_name }}-artifacts.tar.gz \
            --clobber
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "## Release Complete! üöÄ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.version.outputs.tag_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changelog" >> $GITHUB_STEP_SUMMARY
          cat CHANGELOG_TEMP.md >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The \`release\` branch has been fast-forwarded to \`main\` and locked." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Cloudflare Pages will automatically deploy from the \`release\` branch" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment at: https://dash.cloudflare.com" >> $GITHUB_STEP_SUMMARY
          echo "- Verify production site after deployment completes" >> $GITHUB_STEP_SUMMARY
          echo "- Remember to re-lock the release branch via CLI" >> $GITHUB_STEP_SUMMARY

  # Post-deployment verification job
  verify:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: release
    steps:
      - name: Wait for Cloudflare deployment
        run: |
          echo "Waiting 60 seconds for Cloudflare Pages to deploy..."
          sleep 60

      - name: Verify production site
        run: |
          # Use secret PRODUCTION_URL if set, otherwise fail with helpful message
          if [ -z "${{ secrets.PRODUCTION_URL }}" ]; then
            echo "::error::PRODUCTION_URL secret is not configured"
            echo "::error::Please set PRODUCTION_URL in repository secrets"
            echo "::error::Example: https://your-site.pages.dev"
            exit 1
          fi
          
          PROD_URL="${{ secrets.PRODUCTION_URL }}"
          
          echo "Verifying production site at: $PROD_URL"
          
          # Check if site is accessible
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Production site is accessible (HTTP $HTTP_CODE)"
          else
            echo "::error::‚ùå Production site returned HTTP $HTTP_CODE"
            exit 1
          fi
          
          # Basic content verification
          CONTENT=$(curl -s "$PROD_URL")
          if echo "$CONTENT" | grep -q "<!DOCTYPE html>"; then
            echo "‚úÖ Site appears to serve valid HTML"
          else
            echo "::warning::Site content may not be valid HTML"
          fi

      - name: Verification summary
        if: success()
        run: |
          echo "## ‚úÖ Deployment Verified" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Production site is accessible and serving content." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY

      - name: Verification failure summary
        if: failure()
        run: |
          echo "::error::Post-deployment verification failed. Production may be serving a broken release." 
          echo "## ‚ùå Deployment Verification Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Post-deployment verification **failed**. Production may be serving a broken version." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Refer to the rollback procedures documented in the repository." >> $GITHUB_STEP_SUMMARY