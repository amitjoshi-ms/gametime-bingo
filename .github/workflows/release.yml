name: Release to Production

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "release" to confirm'
        required: true
        type: string
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

permissions:
  contents: write
  pull-requests: read

jobs:
  # Pre-release validation job
  validate:
    name: Pre-Release Validation
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm == 'release'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run type check
        run: npm run check

      - name: Run unit tests
        run: npm run test

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: build-artifacts
          path: dist/
          retention-days: 7

  release:
    name: Release to Production
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Determine version
        id: version
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Validate version format (must be X.Y.Z)
          if ! echo "$CURRENT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid version format in package.json: $CURRENT_VERSION"
            echo "::error::Version must be in format X.Y.Z (e.g., 1.0.0)"
            exit 1
          fi
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Bump version based on input
          case "${{ github.event.inputs.version_bump }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          TAG_NAME="v${NEW_VERSION}"
          
          echo "New version: $NEW_VERSION"
          echo "Tag name: $TAG_NAME"
          
          # Output for later steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Get the latest semantic version tag (v*) or fall back to HEAD~10 (then first commit if needed)
          LATEST_TAG=$(git describe --tags --match "v*" --abbrev=0 2>/dev/null || git rev-parse HEAD~10 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Latest tag/commit: $LATEST_TAG"
          
          # Generate changelog from commits
          echo "# Changelog for ${{ steps.version.outputs.tag_name }}" > CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          echo "**Release Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          # Group commits by type (using simple patterns - ^feat matches both feat: and feat(scope):)
          echo "## üöÄ Features" >> CHANGELOG_TEMP.md
          FEATURES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^feat" 2>/dev/null || true)
          if [ -n "$FEATURES" ]; then
            echo "$FEATURES" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No new features" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "## üêõ Bug Fixes" >> CHANGELOG_TEMP.md
          FIXES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^fix" 2>/dev/null || true)
          if [ -n "$FIXES" ]; then
            echo "$FIXES" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No bug fixes" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          
          echo "## üìù Other Changes" >> CHANGELOG_TEMP.md
          OTHER=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --grep="^chore\|^docs\|^refactor\|^test\|^ci" --extended-regexp 2>/dev/null || true)
          if [ -n "$OTHER" ]; then
            echo "$OTHER" | sed 's/^/- /' >> CHANGELOG_TEMP.md
          else
            echo "No other changes" >> CHANGELOG_TEMP.md
          fi
          echo "" >> CHANGELOG_TEMP.md
          
          # Store changelog for release notes
          echo "changelog_file=CHANGELOG_TEMP.md" >> $GITHUB_OUTPUT

      - name: Unlock release branch
        run: |
          # Check if branch protection exists using exit code first
          set +e
          RESPONSE=$(gh api repos/${{ github.repository }}/branches/release/protection 2>&1)
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "Removing branch protection..."
            gh api repos/${{ github.repository }}/branches/release/protection -X DELETE
            echo "Branch protection removed."
          elif echo "$RESPONSE" | grep -q "404"; then
            echo "No branch protection found, skipping unlock."
          else
            echo "::error::Failed to check branch protection: $RESPONSE"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fast-forward release to main and update version
        run: |
          git checkout release
          if ! git merge --ff-only origin/main; then
            echo "::error::Fast-forward merge failed. The release branch may have diverged from main."
            echo "::error::To fix: git checkout release && git reset --hard origin/main (WARNING: this discards release-only commits)"
            exit 1
          fi
          
          # Now update version on the release branch
          npm version ${{ steps.version.outputs.version }} --no-git-tag-version
          git add package.json package-lock.json
          
          # Commit version bump if there were changes; otherwise verify version consistency
          if ! git diff --staged --quiet; then
            git commit -m "chore(release): bump version to ${{ steps.version.outputs.version }}"
          else
            # No changes detected; verify that package.json already matches the expected release version
            PKG_VERSION=$(node -p "require('./package.json').version")
            if [ "$PKG_VERSION" != "${{ steps.version.outputs.version }}" ]; then
              echo "::error::Version mismatch: package.json has $PKG_VERSION but expected ${{ steps.version.outputs.version }}."
              echo "::error::Refusing to create a release with inconsistent version metadata."
              exit 1
            fi
            echo "Version already matches expected: $PKG_VERSION"
          fi
          
          git push origin release

      - name: Create release tag and GitHub release
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Create and push tag
          git tag "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
          
          # Create GitHub release with changelog
          gh release create "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes-file CHANGELOG_TEMP.md \
            --target release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Lock release branch
        run: |
          echo "Applying branch protection..."
          gh api repos/${{ github.repository }}/branches/release/protection \
            -X PUT \
            -H "Accept: application/vnd.github+json" \
            -f lock_branch=true \
            -f required_status_checks=null \
            -f enforce_admins=true \
            -f required_pull_request_reviews=null \
            -f restrictions=null \
            -f allow_force_pushes=false \
            -f allow_deletions=false
          
          # Small delay for API consistency, then verify protection
          sleep 2
          set +e
          PROTECTION=$(gh api repos/${{ github.repository }}/branches/release/protection 2>&1)
          API_EXIT=$?
          set -e
          
          if [ $API_EXIT -ne 0 ]; then
            echo "::error::Failed to fetch branch protection: $PROTECTION"
            exit 1
          fi
          
          if echo "$PROTECTION" | jq -e '.lock_branch == true' > /dev/null 2>&1; then
            echo "Branch protection verified (lock_branch=true)."
          else
            echo "::error::Branch protection applied but lock_branch is not true!"
            echo "Response: $PROTECTION"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4.1.3
        with:
          name: build-artifacts
          path: dist/

      - name: Create release artifacts archive
        run: |
          # Create archive of build artifacts for potential rollback
          tar -czf release-${{ steps.version.outputs.tag_name }}-artifacts.tar.gz dist/
          
          # Upload to release
          gh release upload ${{ steps.version.outputs.tag_name }} \
            release-${{ steps.version.outputs.tag_name }}-artifacts.tar.gz \
            --clobber
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "## Release Complete! üöÄ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.version.outputs.tag_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changelog" >> $GITHUB_STEP_SUMMARY
          cat CHANGELOG_TEMP.md >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The \`release\` branch has been fast-forwarded to \`main\` and locked." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Cloudflare Pages will automatically deploy from the \`release\` branch" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment at: https://dash.cloudflare.com" >> $GITHUB_STEP_SUMMARY
          echo "- Verify production site after deployment completes" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup - Re-lock branch on failure
        if: failure()
        run: |
          echo "::warning::Workflow failed, attempting to re-lock release branch..."
          # Note: We use || true pattern here intentionally. If the main workflow failed,
          # we want to attempt cleanup but not mask the original failure.
          # The warning above and any API error will still be visible in logs.
          gh api repos/${{ github.repository }}/branches/release/protection \
            -X PUT \
            -H "Accept: application/vnd.github+json" \
            -f lock_branch=true \
            -f required_status_checks=null \
            -f enforce_admins=true \
            -f required_pull_request_reviews=null \
            -f restrictions=null \
            -f allow_force_pushes=false \
            -f allow_deletions=false \
            && echo "Branch re-locked successfully." \
            || echo "::error::CRITICAL: Failed to re-lock branch! Manual intervention required."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Post-deployment verification job
  verify:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: release
    steps:
      - name: Wait for Cloudflare deployment
        run: |
          echo "Waiting 60 seconds for Cloudflare Pages to deploy..."
          sleep 60

      - name: Verify production site
        run: |
          # Use secret PRODUCTION_URL if set, otherwise fail with helpful message
          if [ -z "${{ secrets.PRODUCTION_URL }}" ]; then
            echo "::error::PRODUCTION_URL secret is not configured"
            echo "::error::Please set PRODUCTION_URL in repository secrets"
            echo "::error::Example: https://your-site.pages.dev"
            exit 1
          fi
          
          PROD_URL="${{ secrets.PRODUCTION_URL }}"
          
          echo "Verifying production site at: $PROD_URL"
          
          # Check if site is accessible
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Production site is accessible (HTTP $HTTP_CODE)"
          else
            echo "::error::‚ùå Production site returned HTTP $HTTP_CODE"
            exit 1
          fi
          
          # Basic content verification
          CONTENT=$(curl -s "$PROD_URL")
          if echo "$CONTENT" | grep -q "<!DOCTYPE html>"; then
            echo "‚úÖ Site appears to serve valid HTML"
          else
            echo "::warning::Site content may not be valid HTML"
          fi

      - name: Verification summary
        if: success()
        run: |
          echo "## ‚úÖ Deployment Verified" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Production site is accessible and serving content." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
